# 发号器

给每一个过来的长地址，发一个号，小型系统直接用 mysql 的自增索引就搞定了。如果是大型应用，可以考虑各种分布式 key-value 系统做发号器。不停的自增就行了。第一个使用这个服务的人得到的短地址是 http://xx.xx/0 第二个是 http://xx.xx/1 第 11 个是 http://xx.xx/a 第依次往后，相当于实现了一个 62 进制的自增字段。62进制如何用数据库或者 KV 存储来做？其实我们并不需要在存储中用 62 进制，用 10 进制就好了。比如第 10000 个长地址，我们给它的短地址对应的编号是 9999，我们通过存储自增拿到 9999 后，再做一个 10 进制到 62 进制的转换，转成 62 进制数即可。这个 10～62 进制转换

# 唯一性校验

同一个长地址，（尽量做到）每次转出来都是一样的短地址 ，最简单的方案就是用一个哈希表，缺点就是占用空间多，短时间同一个长地址多次点击生成多个不同的短地址，没有意义！使用数据库唯一索引加乐观锁插入

# 如何保证发号器高并发高可用

如果做成分布式的，那么多节点要保持同步加1，多点同时写入，这个嘛，以 CAP 理论看，是不可能真正做到的。其实这个问题的解决非常简单，我们可以退一步考虑，我们是否可以实现两个发号器，一个发单号，一个发双号，这样就变单点为多点了？依次类推，我们可以实现 1000 个逻辑发号器，分别发尾号为 0 到 999 的号。每发一个号，每个发号器加 1000，而不是加 1 。这些发号器独立工作，互不干扰即可。而且在实现上，也可以先是逻辑的，真的压力变大了，再拆分成独立的物理机器单元。1000 个节点，估计对人类来说应该够用了。如果你真的还想更多，理论上也是可以的

# 跳转用 301 还是 302

301 是永久重定向，302 是临时重定向。短地址一经生成就不会变化，所以用 301 是符合 http 语义的。同时对服务器压力也会有一定减少。但是如果使用了 301，我们就无法统计到短地址被点击的次数了。而这个点击次数是一个非常有意思的大数据分析数据源。能够分析出的东西非常非常多。所以选择 302 虽然会增加服务器压力，但是我想是一个更好的选择
