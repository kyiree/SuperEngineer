![image](https://github.com/kyiree/system-design-gpt/assets/64623867/0202777d-bd72-4fd4-8a9f-73824b71c29f)

# 1 需要提前了解的一些知识

- 局部性原理：最近被访问的数据很大可能会在短时间内会再被访问一次
- 缓存存在于系统架构的多个地方
- 所谓的缓存，就是断电就丢失的数据，通常占用较小的存储空间，访问缓存比访问初始数据源的速度会更快

# 2 系统架构中的缓存

## 2.1 客户端缓存

用户在使用浏览器访问网站的时候，可以把网站的一些静态资源缓存在客户端本地，后续浏览器就可以使用缓存而不是直接访问服务器，减轻服务器带宽压力，可以关注的技术：HTTP Cache Headers

## 2.2 DNS 缓存

DNS 将域名转换成 IP 地址的过程是一个递归调用的过程，为了加快这个过程，DNS 服务器都会使用缓存来加快这个转换速度

## 2.3 服务端缓存

这里的内容就比较宽泛了，通常和业务相关，例如将数据库中的数据放到 Redis 缓存中，应用首先访问 Redis ，如果数据不存在才访问数据库；甚至可以在业务应用加缓存，例如在 Java 程序中使用各种数据结构将数据缓存到 JVM 内部，这样的访问速度是最快的

## 2.4 计算机内部缓存

再深入到计算机内部，一般来说 CPU 会从内存中拿数据，为了加快这一过程，还使用了高速缓存，也就是在 CPU 和内存之间再加一个缓存，CPU 访问高速缓存的速度会比直接访问内存会更快；再比如，在操作系统内核中，会将磁盘数据存储在内存中，改数据也是 改内存数据，等到达一定的时间或者用户强制 flush ，才会将内存中的”脏数据“持久化到磁盘中

## 2.5 CDN

[之前记录过](https://github.com/kyiree/system-design-gpt/blob/main/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80/CDN.md)

# 3 如何保证缓存和真实数据的双写一致性

假设数据存在 Redis 和 Mysql 中，在发生修改操作的时候，我们需要保证两边的数据都要同时修改，有下面几种做法：

- Cache-Aside Pattern（旁路缓存）：写的时候先写数据库，然后删除旧的缓存
- Write Back / Write Behind（写回/延迟写入）：数据首先被写入缓存，然后在某个时间点（比如，基于时间或者数量阈值）异步批量写入数据库。这种方式可以减少数据库的写操作次数
- Write through：写缓存和写数据库做成一个原子性操作，强一致性保证

# 4 缓存淘汰策略

为了节省存储空间，或者数据达到一定的阈值需要做数据清理，我们需要有一个机制确定需要淘汰哪些数据，下面是常用的缓存淘汰策略：

- First In First Out (FIFO)：直接淘汰最初的缓存
- Last In First Out (LIFO): 直接淘汰最后的缓存
- Least Recently Used (LRU)：按照访问时间排序，淘汰访问时间距离现在最久的缓存
- Least Frequently Used (LFU)：按照访问次数排序，淘汰访问次数最少的缓存
- Random Replacement (RR)：随机淘汰掉一部分缓存

# 5 缓存风险

## 5.1 缓存穿透

缓存的目的是为了缓解 CPU 或者 I/O 的压力，譬如对数据库做缓存，大部分流量都从缓存中直接返回，只有缓存未能命中的数据请求才会流到数据库中，这样数据库压力自然就减小了。但是如果查询的数据在数据库中根本不存在的话，缓存里自然也不会有，这类请求的流量每次都不会命中，每次都会触及到末端的数据库，缓存就起不到缓解压力的作用了，这种查询不存在数据的现象被称为缓存穿透。缓存穿透有可能是业务逻辑本身就存在的固有问题，也有可能是被恶意攻击的所导致，为了解决缓存穿透，通常会采取下面两种办法：

- 对于业务逻辑本身就不能避免的缓存穿透，可以约定在一定时间内对返回为空的 Key 值依然进行缓存（注意是正常返回但是结果为空，不应把抛异常的也当作空值来缓存了），使得在一段时间内缓存最多被穿透一次。如果后续业务在数据库中对该 Key 值插入了新记录，那应当在插入之后主动清理掉缓存的 Key 值。如果业务时效性允许的话，也可以将对缓存设置一个较短的超时时间来自动处理。
- 对于恶意攻击导致的缓存穿透，通常会在缓存之前设置一个布隆过滤器来解决。所谓恶意攻击是指请求者刻意构造数据库中肯定不存在的 Key 值，然后发送大量请求进行查询。布隆过滤器是用最小的代价来判断某个元素是否存在于某个集合的办法。如果布隆过滤器给出的判定结果是请求的数据不存在，那就直接返回即可，连缓存都不必去查。虽然维护布隆过滤器本身需要一定的成本，但比起攻击造成的资源损耗仍然是值得的。

## 5.2 缓存击穿

我们都知道缓存的基本工作原理是首次从真实数据源加载数据，完成加载后回填入缓存，以后其他相同的请求就从缓存中获取数据，缓解数据源的压力。如果缓存中某些热点数据忽然因某种原因失效了，譬如典型地由于超期而失效，此时又有多个针对该数据的请求同时发送过来，这些请求将全部未能命中缓存，都到达真实数据源中去，导致其压力剧增，这种现象被称为缓存击穿。要避免缓存击穿问题，通常会采取下面的两种办法：

- 加锁同步，以请求该数据的 Key 值为锁，使得只有第一个请求可以流入到真实的数据源中，其他线程采取阻塞或重试策略。如果是进程内缓存出现问题，施加普通互斥锁即可，如果是分布式缓存中出现的问题，就施加分布式锁，这样数据源就不会同时收到大量针对同一个数据的请求了。
- 热点数据由代码来手动管理，缓存击穿是仅针对热点数据被自动失效才引发的问题，对于这类数据，可以直接由开发者通过代码来有计划地完成更新、失效，避免由缓存的策略自动管理。

## 5.3 缓存雪崩

缓存击穿是针对单个热点数据失效，由大量请求击穿缓存而给真实数据源带来压力。有另一种可能是更普遍的情况，不需要是针对单个热点数据的大量请求，而是由于大批不同的数据在短时间内一起失效，导致了这些数据的请求都击穿了缓存到达数据源，同样令数据源在短时间内压力剧增。出现这种情况，往往是系统有专门的缓存预热功能，也可能大量公共数据是由某一次冷操作加载的，这样都可能出现由此载入缓存的大批数据具有相同的过期时间，在同一时刻一起失效。还有一种情况是缓存服务由于某些原因崩溃后重启，此时也会造成大量数据同时失效，这种现象被称为缓存雪崩。要避免缓存雪崩问题，通常会采取下面的三种办法：

- 提升缓存系统可用性，建设分布式缓存的集群。
- 启用透明多级缓存，各个服务节点一级缓存中的数据通常会具有不一样的加载时间，也就分散了它们的过期时间。
- 将缓存的生存期从固定时间改为一个时间段内的随机时间，譬如原本是一个小时过期，那可以缓存不同数据时，设置生存期为 55 分钟到 65 分钟之间的某个随机时间。

## 5.4 缓存污染

缓存污染是指缓存中的数据与真实数据源中的数据不一致的现象。尽管笔者在前面是说过缓存通常不追求强一致性，但这显然不能等同于缓存和数据源间连最终的一致性都可以不要求了。缓存污染多数是由开发者更新缓存不规范造成的，譬如你从缓存中获得了某个对象，更新了对象的属性，但最后因为某些原因，譬如后续业务发生异常回滚了，最终没有成功写入到数据库，此时缓存的数据是新的，数据库中的数据是旧的。

为了尽可能的提高使用缓存时的一致性，已经总结不少更新缓存可以遵循设计模式，譬如 Cache Aside、Read/Write Through、Write Behind Caching 等。其中最简单、成本最低的 Cache Aside 模式是指：读数据时，先读缓存，缓存没有的话，再读数据源，然后将数据放入缓存，再响应请求。写数据时，先写数据源，然后失效（而不是更新）掉缓存。

读数据方面一般没什么出错的余地，但是写数据时，就有必要专门强调两点：一是先后顺序是先数据源后缓存。试想一下，如果采用先失效缓存后写数据源的顺序，那一定存在一段时间缓存已经删除完毕，但数据源还未修改完成，此时新的查询请求到来，缓存未能命中，就会直接流到真实数据源中。这样请求读到的数据依然是旧数据，随后又重新回填到缓存中。当数据源的修改完成后，结果就成了数据在数据源中是新的，在缓存中是老的，两者就会有不一致的情况。另一点是应当失效缓存，而不是去尝试更新缓存，这很容易理解，如果去更新缓存，更新过程中数据源又被其他请求再次修改的话，缓存又要面临处理多次赋值的复杂时序问题。所以直接失效缓存，等下次用到该数据时自动回填，期间无论数据源中的值被改了多少次都不会造成任何影响。

Cache Aside 模式依然是不能保证在一致性上绝对不出问题的，否则就无须设计出Paxos这样复杂的共识算法了。典型的出错场景是如果某个数据是从未被缓存过的，请求会直接流到真实数据源中，如果数据源中的写操作发生在查询请求之后，结果回填到缓存之前，也会出现缓存中回填的内容与数据库的实际数据不一致的情况。但这种情况的概率是很低的，Cache Aside 模式仍然是以低成本更新缓存，并且获得相对可靠结果的解决方案。
