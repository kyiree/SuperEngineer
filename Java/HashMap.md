以 JDK17 源代码为例子阅读 HashMap 源代码和解决相关的技术面试问题

# 1 HashMap 为什么会有并发问题

答：因为没有加锁，设想这种场景，两个线程同时放一个 hashCode 相同的键值对，同时判断这个桶是空，那么就有可能存在一个线程覆盖另一个线程的情况。

# 2 HashMap 每次扩容的大小是多少，为什么

答：每次扩容大小是 2 倍，并且初始容量是 2 的幂次方，当 hash 桶的容量是 2 的 n 次幂时，(n - 1) & hash == hash % n，但是使用位运算比模除运算要快得多，这是因为位运算直接在二进制层面上操作，而模除运算则是算术运算，计算成本更高。

# 3 HashMap 添加一个元素的流程是怎样的

答：因为是延迟初始化，首先判断如果哈希表是空的话，先进行初始化；如果哈希表不为空，则计算得到一个节点需要放在哪个桶，如果该桶没有节点，则直接放置；如果该桶有节点，则通过 equals 对比新节点的 key 和旧节点的 key 是否是同一个，如果是则使用新的 value 替代旧的 value；如果不是则说明发生了哈希冲突，如果该节点的类型是红黑树节点，则往树里面写数据；否则的话，该节点就是普通链表节点，遍历该链表判断数据需要写在哪里，同时判断如果链表的长度大于等于 8 个，则会将链表转换成红黑树。最后判断如果当前哈希表元素数量如果大于（容量*负载因子）的话，就进行扩容。

# 4 HashMap 的扩容过程是怎样的？

答：因为延迟初始化的原因，如果判断哈希表为空，则先进行初始化，初始容量是也是 2 的倍数。到这里流程结束。

如果哈希表不为空，新建一个两倍于原来容量的哈希表，然后将旧哈希表的元素迁移到新的哈希表，下面是迁移的具体过程：循环遍历旧的哈希表，

- 如果当前桶存在节点，首先判断当前节点的 next 属性是否为空，如果 next 属性为空则说明该桶只有一个节点，直接将该节点放在新哈希表里面，桶索引的计算过程也是（hash & (newCap - 1)）；
- 如果当前桶对应的节点是红黑树节点，则进行树的分裂，具体是通过 next 属性遍历整棵树，将整棵树分为低位链表或高位链表，分别对低位链表和高位链表进行处理：
  
    如果链表的节点数小于或者等于 6 ：若是低位头链表则将红黑树退化为链表，并把整个链表放到新的哈希表桶里面，桶位置和原来一样，若是高位头链表则桶位置是原来桶的位置加上原来哈希表大小。
  
    如果链表的节点数大于 6：则保持为树结构，低位头则桶位置和原来一样，高位头则是原来桶的位置加上原来哈希表大小。根据是否分成高低位链表，重新对低位头节点和高位头节点进行重新树化。

- 最后一种情况，当前桶对应的节点是链表节点，也进行链表的分裂，具体是通过 next 属性遍历整个链表，将个链表分为低位链表或高位链表，分别对低位链表和高位链表进行处理：如果是低位链表则桶位置和原来一样，如果是高位链表则桶位置是原来桶的位置加上原来哈希表大小。

至此，将旧哈希表中的元素迁移到两倍容量的新的哈希表中，对红黑树、链表都进行了分裂的操作。
